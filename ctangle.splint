ctangle.w: (in function main)
ctangle.w:140:10: Arrow access of non-pointer (text [2500]):
                     text_info->tok_start
  Types are incompatible. (Use -type to inhibit warning)
ctangle.w:141:23: Unqualified static storage tok_mem assigned to implicitly
                     only: text_ptr->tok_start = tok_mem
  Static storage is transferred in an inconsistent way. (Use -statictrans to
  inhibit warning)
ctangle.w:203:34: Arrow access of non-pointer (text [2500]):
                     text_info->text_link
ctangle.w: (in function names_match)
ctangle.w:161:2: Statement has no effect: (void)t
  Statement has no visible effect --- no values are modified. (Use -noeffect to
  inhibit warning)
ctangle.w: (in function init_node)
ctangle.w:175:1: Unqualified static storage (void *)text_info assigned to
                    implicitly only: node->equiv_or_xref = (void *)text_info
ctangle.w: (in function init_p)
ctangle.w:178:37: Statement has no effect: (void)p
ctangle.w:178:45: Statement has no effect: (void)t
ctangle.w: (in function push_level)
ctangle.w:324:1: Implicitly temp storage p assigned to implicitly only:
                    cur_state.name_field = p
  Temp storage (associated with a formal parameter) is transferred to a
  non-temporary reference. The storage may be released or new aliases created.
  (Use -temptrans to inhibit warning)
ctangle.w:327:1: Clauses exit with p->equiv_or_xref referencing kept storage in
                    true branch, implicitly only storage in continuation
  The state of a variable is different depending on which branch is taken. This
  means no annotation can sensibly be applied to the storage. (Use -branchstate
  to inhibit warning)
   ctangle.w:324:25: Storage p->equiv_or_xref becomes kept
ctangle.w:327:1: Storage cur_state.name_field->equiv_or_xref is kept in one
                    path, but live in another.
   ctangle.w:324:25: Storage cur_state.name_field->equiv_or_xref becomes kept
ctangle.w:327:1: Storage cur_state.repl_field->tok_start is kept in one path,
                    but live in another.
   ctangle.w:325:1: Storage cur_state.repl_field->tok_start becomes kept
ctangle.w: (in function pop_level)
ctangle.w:344:23: Incompatible types for + (sixteen_bits, text [2500]):
                     cur_state.repl_field->text_link + text_info
ctangle.w:349:21: Storage stack_ptr->end_field is released in one path, but
                     live in another.
   ctangle.w:349:21: Storage stack_ptr->end_field released
ctangle.w:349:21: Storage stack_ptr->byte_field is released in one path, but
                     live in another.
   ctangle.w:349:21: Storage stack_ptr->byte_field released
ctangle.w:349:21: Storage stack_ptr->name_field is released in one path, but
                     live in another.
   ctangle.w:349:21: Storage stack_ptr->name_field released
ctangle.w:349:21: Storage stack_ptr->repl_field is released in one path, but
                     live in another.
   ctangle.w:349:21: Storage stack_ptr->repl_field released
ctangle.w: (in function get_output)
ctangle.w:387:32: Operands of != have incompatible types (sixteen_bits, char):
                     a != '\n'
ctangle.w:412:5: Incompatible types for + (sixteen_bits, name_info []):
                    a + name_dir
ctangle.w:412:61: Incompatible types for + (sixteen_bits, name_info []):
                     a + name_dir
ctangle.w:415:20: Incompatible types for + (sixteen_bits, name_info []):
                     a + name_dir
ctangle.w: (in function phase_two)
ctangle.w:305:82: Arrow access of non-pointer (text [2500]):
                     text_info->text_link
ctangle.w:527:13: Arrow access of non-pointer (text [2500]):
                     text_info->text_link
ctangle.w:545:13: Arrow access of non-pointer (text [2500]):
                     text_info->text_link
ctangle.w:580:1: Storage *an_output_file->equiv_or_xref is kept in one path,
                    but live in another.
   ctangle.w:575:1: Storage *an_output_file->equiv_or_xref becomes kept
ctangle.w:580:1: Storage cur_state.name_field->equiv_or_xref is kept in one
                    path, but live in another.
   ctangle.w:575:1: Storage cur_state.name_field->equiv_or_xref becomes kept
ctangle.w:580:1: Clauses exit with cur_state.end_field referencing kept storage
    in for body, implicitly only storage if for loop body does not execute
   ctangle.w:577:1: Storage cur_state.end_field becomes kept
ctangle.w:580:1: Clauses exit with *end_output_files->equiv_or_xref referencing
    kept storage in for body, implicitly only storage if for loop body does not
    execute
   ctangle.w:575:1: Storage *end_output_files->equiv_or_xref becomes kept
ctangle.w:554:1: Storage *end_output_files is kept in one path, but live in
                    another.
   ctangle.w:574:1: Storage *end_output_files becomes kept
ctangle.w:554:1: Storage *an_output_file is kept in one path, but live in
                    another.
   ctangle.w:574:1: Storage *an_output_file becomes kept
ctangle.w: (in function output_defs)
ctangle.w:605:12: Null storage passed as non-null param: push_level (NULL)
  A possibly null pointer is passed as a parameter corresponding to a formal
  parameter with no /*@null@*/ annotation.  If NULL may be used for this
  parameter, add a /*@null@*/ annotation to the function parameter declaration.
  (Use -nullpass to inhibit warning)
ctangle.w:609:1: Kept storage cur_text->tok_start assigned to implicitly only:
                    cur_state.end_field = (cur_text + 1)->tok_start
  storage is transferred to a non-temporary reference after being passed as
  keep parameter. The storage may be released or new aliases created. (Use
  -kepttrans to inhibit warning)
   ctangle.w:608:1: Storage cur_text->tok_start becomes kept
ctangle.w:615:47: Operands of == have incompatible types (sixteen_bits, char):
                     a == '\n'
ctangle.w:616:32: Operands of != have incompatible types (sixteen_bits, char):
                     a != '\n'
ctangle.w:635:1: Storage cur_text->tok_start is kept in one path, but live in
                    another.
   ctangle.w:608:1: Storage cur_text->tok_start becomes kept
ctangle.w:635:1: Clauses exit with text_info->tok_start referencing kept
    storage in true branch, implicitly only storage in continuation
   ctangle.w:608:1: Storage text_info->tok_start becomes kept
ctangle.w:635:1: Storage cur_state.byte_field is kept in one path, but live in
                    another.
   ctangle.w:609:1: Storage cur_state.byte_field becomes kept
ctangle.w: (in function out_char)
ctangle.w:715:9: Incompatible types for + (int, name_info []):
                    cur_val + name_dir
ctangle.w:715:43: Incompatible types for + (int, name_info []):
                     cur_val + name_dir
ctangle.w:738:9: Incompatible types for + (int, name_info []):
                    cur_val + name_dir
ctangle.w:738:43: Incompatible types for + (int, name_info []):
                     cur_val + name_dir
ctangle.w:670:9: Fall through case (no preceding break)
  Execution falls through from the previous case (use /*@fallthrough@*/ to mark
  fallthrough cases). (Use -casebreak to inhibit warning)
ctangle.w: (in function get_next)
ctangle.w:900:24: Operands of == have incompatible types (eight_bits, char):
                     c == '/'
ctangle.w:901:57: Return value type char does not match declared type
                     eight_bits: '\n'
ctangle.w:906:55: Operands of == have incompatible types (eight_bits, char):
                     c == '.'
ctangle.w:907:9: Operands of == have incompatible types (eight_bits, char):
                    c == '\''
ctangle.w:907:18: Operands of == have incompatible types (eight_bits, char):
                     c == '"'
ctangle.w:908:5: Operands of == have incompatible types (eight_bits, char):
                    c == 'L'
ctangle.w:908:13: Operands of == have incompatible types (eight_bits, char):
                     c == 'u'
ctangle.w:908:21: Operands of == have incompatible types (eight_bits, char):
                     c == 'U'
ctangle.w:909:5: Operands of == have incompatible types (eight_bits, char):
                    c == 'u'
ctangle.w:1025:4: Operands of == have incompatible types (eight_bits, char):
                     (c = (eight_bits)*loc++) == delim
ctangle.w:1029:4: Operands of == have incompatible types (eight_bits, char):
                     c == '\\'
ctangle.w:911:27: Operands of == have incompatible types (eight_bits, char):
                     (c) == '_'
ctangle.w:911:38: Operands of == have incompatible types (eight_bits, char):
                     (c) == '$'
ctangle.w:913:9: Operands of == have incompatible types (eight_bits, char):
                    c == '@'
ctangle.w:1054:17: Operands of == have incompatible types (eight_bits, char):
                      (c = skip_ahead()) == '@'
ctangle.w:1140:4: Operands of == have incompatible types (eight_bits, char):
                     c == '@'
ctangle.w:1142:4: Operands of == have incompatible types (eight_bits, char):
                     c == '>'
ctangle.w:920:9: Operands of == have incompatible types (eight_bits, char):
                    c == '#'
ctangle.w:924:2: Path with no return in function declared to return eight_bits
  There is a path through a function declared to return a value on which there
  is no return statement. This means the execution may fall through without
  returning a meaningful result to the caller. (Use -noret to inhibit warning)
ctangle.w: (in function scan_repl)
ctangle.w:1231:12: Variable a shadows outer declaration
  An outer declaration is shadowed by the local declaration. (Use -shadow to
  inhibit warning)
   ctangle.w:1202:14: Previous definition of a: sixteen_bits
ctangle.w:1315:4: Operands of == have incompatible types (int, char): c == '\\'
  A character constant is used as an int. Use +charintliteral to allow
  character constants to be used as ints.  (This is safe since the actual type
  of a char constant is int.)
ctangle.w:1317:4: Operands of >= have incompatible types (int, char): c >= '0'
ctangle.w:1317:12: Operands of <= have incompatible types (int, char): c <= '7'
ctangle.w:1318:1: Incompatible types for -= (int, char): c -= '0'
ctangle.w:1320:4: Incompatible types for + (int, char): 8 * c + *(++id_first)
  To make char and int types equivalent, use +charint.
ctangle.w:1322:4: Incompatible types for + (int, char): 8 * c + *(++id_first)
ctangle.w:1326:9: Assignment of char to int: c = '\t'
ctangle.w:1327:9: Assignment of char to int: c = '\n'
ctangle.w:1328:9: Assignment of char to int: c = '\b'
ctangle.w:1329:9: Assignment of char to int: c = '\f'
ctangle.w:1330:9: Assignment of char to int: c = '\v'
ctangle.w:1331:9: Assignment of char to int: c = '\r'
ctangle.w:1332:9: Assignment of char to int: c = '\7'
ctangle.w:1333:9: Assignment of char to int: c = '?'
ctangle.w:1346:10: Assignment of char to int: c = '\\'
ctangle.w:1347:10: Assignment of char to int: c = '\''
ctangle.w:1348:10: Assignment of char to int: c = '\"'
ctangle.w:1214:20: Variable a used before definition
  An rvalue is used that may not be initialized to a value on some execution
  path. (Use -usedef to inhibit warning)
ctangle.w: (in function scan_section)
ctangle.w:1420:7: Operands of == have incompatible types (eight_bits, char):
                     (next_control = get_next()) == '\n'
ctangle.w:1442:7: Operands of == have incompatible types (eight_bits, char):
                     (next_control = get_next()) == '+'
ctangle.w:1443:4: Operands of != have incompatible types (eight_bits, char):
                     next_control != '='
ctangle.w:1456:4: Variable p used before definition
ctangle.w:1459:44: Unqualified static storage (void *)cur_text assigned to
                      implicitly only: p->equiv_or_xref = (void *)cur_text
ctangle.w:1464:4: Incompatible types for + (sixteen_bits, text [2500]):
                     q->text_link + text_info
ctangle.w:1466:1: Variable cur_text is kept in true branch, but not kept in
                     false branch.
   ctangle.w:1466:1: in true branch:
   ctangle.w:1459:44: Storage cur_text becomes kept
ctangle.w: (in function skip_limbo)
ctangle.w:1507:9: Fall through case (no preceding break)

